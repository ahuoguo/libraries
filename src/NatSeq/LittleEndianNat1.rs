
use vstd::prelude::*;
#[allow(unused_imports)]
use vstd::seq_lib::*;
#[allow(unused_imports)]
use vstd::seq::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Div::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Modulus::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Mul::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Power::*;
#[allow(unused_imports)]
use vstd::calc_macro::*;
#[allow(unused_imports)]
use crate::NatSeq::LittleEndianNat::*;


verus! {

//////////////////////////////////////////////////////////////////////////////
//
// from_nat definition and lemmas (put to LittleEndianNat1.rs)
//
//////////////////////////////////////////////////////////////////////////////

/// converts a nat to a sequence
spec fn from_nat(n: nat, base: int) -> (xs: Seq<int>)
    recommends base > 1
    decreases n 
    when base > 1
    via from_nat_decreases
    // ensures to_nat_right(xs, base) == n
{
    if n == 0 {
        seq![]
    } else {
        seq![n as int % base] + from_nat((n as int / base) as nat, base)
    }
}

#[via_fn]
proof fn from_nat_decreases(n: nat, base: int) 
{
    lemma_div_basics_auto();
    if n > 0 && base > 1 {
        lemma_div_decreases_auto();
        assert(((n as int / base) as nat) < n);
    }
}

//   /* Converts a nat to a sequence. */
//   function {:opaque} from_nat(n: nat): (xs: seq<uint>)
//   {
//     if n == 0 then []
//     else
//       LemmaDivBasicsAuto();
//       LemmaDivDecreasesAuto();
//       [n % BASE()] + from_nat(n / BASE())
//   }


// /* Ensures length of the sequence generated by from_nat is less than len.
// Helper proof fn for from_natWithLen. */
// pub proof fn lemma_from_nat_len(n: nat, len: nat)
// requires pow(base, len) > n
// ensures |from_nat(n)| <= len
// {
// reveal from_nat();
// if n == 0 {
// } else {
//     calc {
//     |from_nat(n)|;
//     == { lemma_div_basics_auto(); }
//     1 + |from_nat(n / base)|;
//     <= {
//         lemma_multiply_divide_lt_auto();
//         lemma_div_decreases_auto();
//         reveal pow();
//         lemma_from_nat_len(n / base, len - 1);
//         }
//     len;
//     }
// }
// }

// /* If we start with a nat, convert it to a sequence, and convert it back, we
// get the same nat we started with. */
// pub proof fn lemma_nat_seq_nat(n: nat)
// ensures to_nat_right(from_nat(n)) == n
// decreases n
// {
// reveal to_nat_right();
// reveal from_nat();
// if n == 0 {
// } else {
//     calc {
//     to_nat_right(from_nat(n));
//     { lemma_div_basics_auto(); }
//     to_nat_right([n % base] + from_nat(n / base));
//     n % base + to_nat_right(from_nat(n / base)) * base;
//     {
//         lemma_div_decreases_auto();
//         lemma_nat_seq_nat(n / base);
//     }
//     n % base + n / base * base;
//     { lemma_fundamental_div_mod(n, base); }
//     n;
//     }
// }
// }

// /* Extends a sequence to a specified length. */
// function {:opaque} SeqExtend(xs: Seq<int>, n: nat): (ys: Seq<int>)
// requires |xs| <= n
// ensures |ys| == n
// ensures to_nat_right(ys, base) == to_nat_right(xs, base)
// decreases n - |xs|
// {
// if |xs| >= n then xs else lemma_seq_append_zero(xs); SeqExtend(xs + seq![0], n)
// }

// /* Extends a sequence to a length that is a multiple of n. */
// function {:opaque} SeqExtendMultiple(xs: Seq<int>, n: nat): (ys: Seq<int>)
// requires n > 0
// ensures |ys| % n == 0
// ensures to_nat_right(ys, base) == to_nat_right(xs, base)
// {
// var newLen := |xs| + n - (|xs| % n);
// lemma_sub_mod_noop_right(|xs| + n, |xs|, n);
// lemma_mod_basics_auto();
// assert newLen % n == 0;

// lemma_seq_nat_bound(xs);
// lemma_pow_increases_auto();
// SeqExtend(xs, newLen)
// }

// /* Converts a nat to a sequence of a specified length. */
// function {:opaque} from_natWithLen(n: nat, len: nat): (xs: Seq<int>, base: int)
// requires pow(base, len) > n
// ensures |xs| == len
// ensures to_nat_right(xs, base) == n
// {
// lemma_from_nat_len(n, len);
// lemma_nat_seq_nat(n);
// SeqExtend(from_nat(n), len)
// }

// /* If the nat representation of a sequence is zero, then the sequence is a
// sequence of zeros. */
// pub proof fn lemma_seq_zero(xs: Seq<int>, base: int)
// requires to_nat_right(xs, base) == 0
// ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0
// {
// reveal to_nat_right();
// if |xs| == 0 {
// } else {
//     lemma_mul_nonnegative_auto();
//     assert xs.first() == 0;

//     lemma_mul_nonzero_auto();
//     lemma_seq_zero(xs.drop_first());
// }
// }

// /* Generates a sequence of zeros of a specified length. */
// function {:opaque} SeqZero(len: nat): (xs: Seq<int>, base: int)
// ensures |xs| == len
// ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0
// ensures to_nat_right(xs, base) == 0
// {
// lemma_pow_positive(base, len);
// var xs := from_natWithLen(0, len);
// lemma_seq_zero(xs);
// xs
// }

// /* If we start with a sequence, convert it to a nat, and convert it back to a
// sequence with the same length as the original sequence, we get the same
// sequence we started with. */
// pub proof fn lemma_seq_nat_seq(xs: Seq<int>, base: int)
// ensures pow(base, |xs|) > to_nat_right(xs, base)
// ensures from_natWithLen(to_nat_right(xs, base), |xs|) == xs
// {
// reveal from_nat();
// reveal to_nat_right();
// lemma_seq_nat_bound(xs);
// if |xs| > 0 {
//     calc {
//     from_natWithLen(to_nat_right(xs, base), |xs|) != xs;
//     { lemma_seq_neq(from_natWithLen(to_nat_right(xs, base), |xs|), xs); }
//     to_nat_right(from_natWithLen(to_nat_right(xs, base), |xs|)) != to_nat_right(xs, base);
//     to_nat_right(xs, base) != to_nat_right(xs, base);
//     false;
//     }
// }
// }

// //////////////////////////////////////////////////////////////////////////////
// //
// // Addition and subtraction
// //
// //////////////////////////////////////////////////////////////////////////////

// /* Adds two sequences. */
// function {:opaque} SeqAdd(xs: Seq<int>, ys: Seq<int>): (Seq<int>, nat)
// requires |xs| == |ys|
// ensures var (zs, cout) := SeqAdd(xs, ys);
//         |zs| == |xs| && 0 <= cout <= 1
// decreases xs
// {
// if |xs| == 0 then ([], 0)
// else
//     var (zs', cin) := SeqAdd(xs.drop_last(), DropLast(ys));
//     var sum: int := xs.last() + Last(ys) + cin;
//     var (sum_out, cout) := if sum < base then (sum, 0)
//                             else (sum - base, 1);
//     (zs' + [sum_out], cout)
// }

// /* SeqAdd returns the same value as converting the sequences to nats, then
// adding them. */
// proof fn vcs_split_on_every_assert} lemma_seq_add(xs: Seq<int>, ys: Seq<int>, zs: Seq<int>, cout: nat)
// requires |xs| == |ys|
// requires SeqAdd(xs, ys) == (zs, cout)
// ensures to_nat_right(xs, base) + to_nat_right(ys, base) == to_nat_right(zs) + cout * pow(base, |xs|)
// {
// reveal SeqAdd();
// if |xs| == 0 {
//     reveal to_nat_right();
// } else {
//     var pow := pow(base, (xs.len() - 1) as nat);
//     var (zs', cin) := SeqAdd(xs.drop_last(), DropLast(ys));
//     var sum: int := xs.last() + Last(ys) + cin;
//     var z := if sum < base then sum else sum - base;
//     assert sum == z + cout * base;

//     reveal to_nat_left();
//     lemma_to_nat_left_eqto_nat_right_auto();
//     calc {
//     to_nat_right(zs);
//     to_nat_left(zs);
//     to_nat_left(zs') + z * pow;
//     { lemma_seq_add(xs.drop_last(), DropLast(ys), zs', cin); }
//     to_nat_left(xs.drop_last()) + to_nat_left(DropLast(ys)) - cin * pow + z * pow;
//     {
//         lemma_mul_equality(sum, z + cout * base, pow);
//         assert sum * pow == (z + cout * base) * pow;
//         lemma_mul_is_distributive_auto();
//     }
//     to_nat_left(xs, base) + to_nat_left(ys, base) - cout * base * pow;
//     {
//         lemma_mul_is_associative(cout, base, pow);
//         reveal pow();
//     }
//     to_nat_left(xs, base) + to_nat_left(ys, base) - cout * pow(base, |xs|);
//     to_nat_right(xs, base) + to_nat_right(ys, base) - cout * pow(base, |xs|);
//     }
// }
// }

// /* Subtracts two sequences. */
// function {:opaque} SeqSub(xs: Seq<int>, ys: Seq<int>): (Seq<int>, nat)
// requires |xs| == |ys|
// ensures var (zs, cout) := SeqSub(xs, ys);
//         |zs| == |xs| && 0 <= cout <= 1
// decreases xs
// {
// if |xs| == 0 then ([], 0)
// else
//     var (zs, cin) := SeqSub(xs.drop_last(), DropLast(ys));
//     var (diff_out, cout) := if xs.last() >= Last(ys) + cin
//                             then (xs.last() - Last(ys) - cin, 0)
//                             else (base + xs.last() - Last(ys) - cin, 1);
//     (zs + [diff_out], cout)
// }

// /* SeqSub returns the same value as converting the sequences to nats, then
// subtracting them. */
// proof fn vcs_split_on_every_assert} lemma_seq_sub(xs: Seq<int>, ys: Seq<int>, zs: Seq<int>, cout: nat)
// requires |xs| == |ys|
// requires SeqSub(xs, ys) == (zs, cout)
// ensures to_nat_right(xs, base) - to_nat_right(ys, base) + cout * pow(base, |xs|) == to_nat_right(zs)
// {
// reveal SeqSub();
// if |xs| == 0 {
//     reveal to_nat_right();
// } else {
//     var pow := pow(base, (xs.len() - 1) as nat);
//     var (zs', cin) := SeqSub(xs.drop_last(), DropLast(ys));
//     var z := if xs.last() >= Last(ys) + cin
//     then xs.last() - Last(ys) - cin
//     else base + xs.last() - Last(ys) - cin;
//     assert cout * base + xs.last() - cin - Last(ys) == z;

//     reveal to_nat_left();
//     lemma_to_nat_left_eqto_nat_right_auto();
//     calc {
//     to_nat_right(zs);
//     to_nat_left(zs);
//     to_nat_left(zs') + z * pow;
//     { lemma_seq_sub(xs.drop_last(), DropLast(ys), zs', cin); }
//     to_nat_left(xs.drop_last()) - to_nat_left(DropLast(ys)) + cin * pow + z * pow;
//     {
//         lemma_mul_equality(cout * base + xs.last() - cin - Last(ys), z, pow);
//         assert pow * (cout * base + xs.last() - cin - Last(ys)) == pow * z;
//         lemma_mul_is_distributive_auto();
//     }
//     to_nat_left(xs, base) - to_nat_left(ys, base) + cout * base * pow;
//     {
//         lemma_mul_is_associative(cout, base, pow);
//         reveal pow();
//     }
//     to_nat_left(xs, base) - to_nat_left(ys, base) + cout * pow(base, |xs|);
//     to_nat_right(xs, base) - to_nat_right(ys, base) + cout * pow(base, |xs|);
//     }
// }
// }
}