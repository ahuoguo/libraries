
use vstd::prelude::*;
#[allow(unused_imports)]
use vstd::seq_lib::*;
#[allow(unused_imports)]
use vstd::seq::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Div::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Modulus::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Mul::*;
#[allow(unused_imports)]
use crate::NonLinearArith::Power::*;
#[allow(unused_imports)]
use vstd::calc_macro::*;
#[allow(unused_imports)]
use crate::NatSeq::LittleEndianNat::*;


verus! {

//////////////////////////////////////////////////////////////////////////////
//
// from_nat definition and lemmas (put to LittleEndianNat1.rs)
//
//////////////////////////////////////////////////////////////////////////////

/// converts a nat to a sequence
pub open spec fn from_nat(n: nat, base: int) -> (xs: Seq<int>)
    recommends base > 1
    decreases n 
    when base > 1
    via from_nat_decreases
    // ensures to_nat_right(xs, base) == n
{
    if n == 0 {
        seq![]
    } else {
        seq![n as int % base] + from_nat((n as int / base) as nat, base)
    }
}


//   /* Converts a nat to a sequence. */
//   function {:opaque} from_nat(n: nat): (xs: seq<uint>)
//   {
//     if n == 0 then []
//     else
//       LemmaDivBasicsAuto();
//       LemmaDivDecreasesAuto();
//       [n % BASE()] + from_nat(n / BASE())
//   }

#[via_fn]
proof fn from_nat_decreases(n: nat, base: int) 
{
    lemma_div_basics_auto();
    if n > 0 && base > 1 {
        lemma_div_decreases_auto();
        assert(((n as int / base) as nat) < n);
    }
}


proof fn from_nat_dec(n: nat, base: int) 
{
    lemma_div_basics_auto();
    if n > 0 && base > 1 {
        lemma_div_decreases_auto();
        assert(((n as int / base) as nat) < n);
    }
}


/// Ensures length of the sequence generated by from_nat is less than len.
/// Helper lemma for from_natWithLen.
pub proof fn lemma_from_nat_len(n: nat, len: nat, base: int)
    requires 
        pow(base, len) > n,
        base > 1,
    ensures 
        from_nat(n, base).len() <= len
    decreases n
{
    reveal(from_nat);
    if n == 0 {
    } else {
        // prove decreases
        assert (((n as int / base) as nat) < n) by {
            lemma_multiply_divide_lt_auto();
            lemma_div_decreases_auto();
            lemma_div_pos_is_pos_auto(); // OBSERVE: need to reason (n as int / base) >= 0
        };

        assert ( pow(base, (len - 1) as nat) >  (n as int / base) as nat) by {
            assert(pow(base, len) > n);
            reveal(pow);
            assert(base * pow(base, (len - 1) as nat) > n);
            lemma_multiply_divide_lt_auto();
            lemma_mul_basics_auto();
            assert(pow(base, (len - 1) as nat) > (n as int / base));
            lemma_div_pos_is_pos_auto(); // OBSERVE: need to reason (n as int / base) >= 0
        }
    
        assert( 1 + from_nat((n as int / base) as nat, base).len() <= len ) by {
            lemma_multiply_divide_lt_auto();
            lemma_div_decreases_auto();
            reveal(pow);
            lemma_from_nat_len((n as int / base) as nat, (len - 1) as nat, base);
        }

        calc! { (<=)
        from_nat(n, base).len();
        (==) { lemma_div_basics_auto(); }
        1 + from_nat((n as int / base) as nat, base).len();
        (<=) {
            // lemma_multiply_divide_lt_auto();
            // lemma_div_decreases_auto();
            // reveal(pow);
            // lemma_from_nat_len((n as int / base) as nat, (len - 1) as nat, base);
            }
        len;
        }
    }
}

// recomends check for to_nat_right
proof fn from_nat_elmts(n: nat, base: int)
    requires
        base > 1
    ensures
        forall |x: int| from_nat(n, base).contains(x) ==> 0 <= x < base,
    decreases n
{

    assert forall |x: int| from_nat(n, base).contains(x) implies 0 <= x < base by {
        // reveal(from_nat);
        if n == 0 {
        } else {
            assert(from_nat(n, base) == seq![n as int % base] + from_nat((n as int / base) as nat, base));
            if seq![n as int % base].contains(x) {

            } else {
                assert(from_nat((n as int / base) as nat, base).contains(x));
                // prove decreases
                assert (((n as int / base) as nat) < n) by {
                    lemma_multiply_divide_lt_auto();
                    lemma_div_decreases_auto();
                    lemma_div_pos_is_pos_auto(); // OBSERVE: need to reason (n as int / base) >= 0
                };
                from_nat_elmts((n as int / base) as nat, base);
            }
        }
    }
}


/// If we start with a nat, convert it to a sequence, and convert it back, we
/// get the same nat we started with.
pub proof fn lemma_nat_seq_nat(n: nat, base: int)
    requires
        base > 1
    ensures 
        to_nat_right(from_nat(n, base), base) == n
    decreases n
{
    reveal(to_nat_right);
    reveal(from_nat);
    if n == 0 {
    } else {

        assert ((n / base as nat) < n) by {
            lemma_div_basics_auto();
            lemma_div_decreases_auto();
        }
        // from_nat(n / (base as nat), base)
        assert forall |x: int| #[trigger](from_nat(n / (base as nat), base).contains(x)) implies 0 <= x < base by {
            from_nat_elmts(n / (base as nat), base);
        }

        from_nat_elmts(n, base); // TODO
        assert(to_nat_right(from_nat(n, base), base) 
           ==  to_nat_right(seq![(n as int % base)] + from_nat(n / (base as nat), base), base)) by {
            lemma_div_basics_auto();
        }

        assert (to_nat_right(seq![(n as int % base)] + from_nat(n / (base as nat), base), base) 
            == (n as int % base) + to_nat_right(from_nat(n / (base as nat), base), base) * base) by {
                reveal(to_nat_right);
                assert( (n as int % base) == (seq![(n as int % base)] + from_nat(n / (base as nat), base)).first());
                assert((seq![(n as int % base)] + from_nat(n / (base as nat), base)).drop_first() =~= from_nat(n / (base as nat), base));
            }

        assert ((n as int % base) + to_nat_right(from_nat(n / (base as nat), base), base) * base 
              == (n as int % base) + n as int / base * base) by {
            lemma_div_decreases_auto();
            lemma_nat_seq_nat(n / base as nat, base);
            assert( to_nat_right(from_nat(n / (base as nat), base), base) == n / (base as nat));
            assert( to_nat_right(from_nat(n / (base as nat), base), base) * base == (n / (base as nat)) * base );
            assert( n as int / base == (n / (base as nat)) ) by {
                lemma_div_pos_is_pos_auto(); // OBSERVE: need to reason (n as int / base) >= 0
            };
        }

        assert (n as int % base + n as int / base * base == n as int) by {
            lemma_div_pos_is_pos_auto(); // OBSERVE: need to reason (n as int / base) >= 0

            lemma_fundamental_div_mod(n as int, base);
        }

        calc! { (==)
        to_nat_right(from_nat(n, base), base);
        { lemma_div_basics_auto(); }
        to_nat_right(seq![(n as int % base)] + from_nat(n / (base as nat), base), base);
        {}
        (n as int % base) + to_nat_right(from_nat(n / (base as nat), base), base) * base;
        {
            lemma_div_decreases_auto();
            lemma_nat_seq_nat(n / base as nat, base);
        }
        n as int % base + n as int / base * base;
        { lemma_fundamental_div_mod(n as int, base); }
        n as int;
        }
    }
}

/// Extends a sequence to a specified length.
#[verifier::opaque]
pub open spec fn seq_extend(xs: Seq<int>, n: nat, base: int) -> (ys: Seq<int>)
    recommends 
        xs.len() <= n,
        base > 1,
        forall |x: int| xs.contains(x) ==> 0 <= x < base,
    // ensures
    //     ys.len() == n,
    //     to_nat_right(ys, base) == to_nat_right(xs, base),
    decreases 
        n - xs.len()
{
    if xs.len() >= n { 
        xs 
    } else {
        // lemma_seq_append_zero(xs, base); 
        seq_extend(xs + seq![0], n, base)
    }
}

proof fn lemma_seq_extend(xs: Seq<int>, n: nat, base: int)
    requires
        xs.len() <= n,
        base > 1,
        forall |x: int| xs.contains(x) ==> 0 <= x < base,
    ensures
        ({
        let ys = seq_extend(xs, n, base);
        ys.len() == n &&
        to_nat_right(ys, base) == to_nat_right(xs, base)
        })
    decreases 
        n - xs.len()
{
    assert forall |x: int| (xs + seq![0]).contains(x) implies 0 <= x < base by {
        if xs.contains(x) {
            assert( 0 <= x < base );
        } else {
            assert( 0 <= x < base );
        }
    }
    
    reveal(seq_extend);

    let ys = seq_extend(xs, n, base);
    reveal(seq_extend);
    if xs.len() >= n {
    } else {
        lemma_seq_append_zero(xs, base);
        lemma_seq_extend(xs + seq![0], n, base);
        assert(ys.len() == n);
        assert(to_nat_right(ys, base) == to_nat_right(xs, base));
    }
}

// /// Extends a sequence to a length that is a multiple of n. 
// function {:opaque} SeqExtendMultiple(xs: Seq<int>, n: nat): (ys: Seq<int>)
//     requires n > 0
//     ensures |ys| % n == 0
//     ensures to_nat_right(ys, base) == to_nat_right(xs, base)
// {
//     var newLen := |xs| + n - (|xs| % n);
//     lemma_sub_mod_noop_right(|xs| + n, |xs|, n);
//     lemma_mod_basics_auto();
//     assert newLen % n == 0;

//     lemma_seq_nat_bound(xs);
//     lemma_pow_increases_auto();
//     seq_extend(xs, newLen)
// }

// /* Converts a nat to a sequence of a specified length. */
// function {:opaque} from_natWithLen(n: nat, len: nat): (xs: Seq<int>, base: int)
// requires pow(base, len) > n
// ensures |xs| == len
// ensures to_nat_right(xs, base) == n
// {
// lemma_from_nat_len(n, len);
// lemma_nat_seq_nat(n);
// seq_extend(from_nat(n), len)
// }

/* If the nat representation of a sequence is zero, then the sequence is a
sequence of zeros. */
pub proof fn lemma_seq_zero(xs: Seq<int>, base: int)
    requires 
        base > 1,
        forall |x: int| xs.contains(x) ==> 0 <= x < base,
        to_nat_right(xs, base) == 0,
    ensures
        forall |i: int| 0 <= i < xs.len() as int ==> (xs[i] == 0)
    decreases xs.len()
{
    reveal(to_nat_right);
    assert(forall |x: int| xs.contains(x) ==> 0 <= x < base);
    assert forall |i: int| 0 <= i < xs.len() as int implies (xs[i] == 0) by {
        if xs.len() == 0 {
            assert (xs[i] == 0) ;
        } else {
            assert forall |x: int| xs.drop_first().contains(x) implies 0 <= x < base by {
                assert( xs.contains(x) );
                // assert( 0 <= x < base );
            }
            assert(to_nat_right(xs, base) == (to_nat_right(xs.drop_first(), base) * base + xs.first()));
            lemma_to_nat_basics(xs.drop_first(), base);
            lemma_mul_nonnegative_auto();
            assert(xs.contains(xs.first()));
            assert(xs.first() == 0);
            
            lemma_mul_nonzero_auto();
            lemma_seq_zero(xs.drop_first(), base);
            // assert(forall |j: int| 0 <= j < xs.drop_first().len() as int ==> (xs.drop_first()[j] == 0));
            assert( i >= 1 ==> xs[i] == xs.drop_first()[i - 1] );
        }
    }
}

// /* Generates a sequence of zeros of a specified length. */
// function {:opaque} SeqZero(len: nat): (xs: Seq<int>, base: int)
// ensures |xs| == len
// ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0
// ensures to_nat_right(xs, base) == 0
// {
// lemma_pow_positive(base, len);
// var xs := from_natWithLen(0, len);
// lemma_seq_zero(xs);
// xs
// }

// /* If we start with a sequence, convert it to a nat, and convert it back to a
// sequence with the same length as the original sequence, we get the same
// sequence we started with. */
// pub proof fn lemma_seq_nat_seq(xs: Seq<int>, base: int)
// ensures pow(base, |xs|) > to_nat_right(xs, base)
// ensures from_natWithLen(to_nat_right(xs, base), |xs|) == xs
// {
// reveal from_nat();
// reveal to_nat_right();
// lemma_seq_nat_bound(xs);
// if |xs| > 0 {
//     calc {
//     from_natWithLen(to_nat_right(xs, base), |xs|) != xs;
//     { lemma_seq_neq(from_natWithLen(to_nat_right(xs, base), |xs|), xs); }
//     to_nat_right(from_natWithLen(to_nat_right(xs, base), |xs|)) != to_nat_right(xs, base);
//     to_nat_right(xs, base) != to_nat_right(xs, base);
//     false;
//     }
// }
// }

// //////////////////////////////////////////////////////////////////////////////
// //
// // Addition and subtraction
// //
// //////////////////////////////////////////////////////////////////////////////

// /* Adds two sequences. */
// function {:opaque} SeqAdd(xs: Seq<int>, ys: Seq<int>): (Seq<int>, nat)
// requires |xs| == |ys|
// ensures var (zs, cout) := SeqAdd(xs, ys);
//         |zs| == |xs| && 0 <= cout <= 1
// decreases xs
// {
// if |xs| == 0 then ([], 0)
// else
//     var (zs', cin) := SeqAdd(xs.drop_last(), DropLast(ys));
//     var sum: int := xs.last() + Last(ys) + cin;
//     var (sum_out, cout) := if sum < base then (sum, 0)
//                             else (sum - base, 1);
//     (zs' + [sum_out], cout)
// }

// /* SeqAdd returns the same value as converting the sequences to nats, then
// adding them. */
// proof fn vcs_split_on_every_assert} lemma_seq_add(xs: Seq<int>, ys: Seq<int>, zs: Seq<int>, cout: nat)
// requires |xs| == |ys|
// requires SeqAdd(xs, ys) == (zs, cout)
// ensures to_nat_right(xs, base) + to_nat_right(ys, base) == to_nat_right(zs) + cout * pow(base, |xs|)
// {
// reveal SeqAdd();
// if |xs| == 0 {
//     reveal to_nat_right();
// } else {
//     var pow := pow(base, (xs.len() - 1) as nat);
//     var (zs', cin) := SeqAdd(xs.drop_last(), DropLast(ys));
//     var sum: int := xs.last() + Last(ys) + cin;
//     var z := if sum < base then sum else sum - base;
//     assert sum == z + cout * base;

//     reveal to_nat_left();
//     lemma_to_nat_left_eqto_nat_right_auto();
//     calc {
//     to_nat_right(zs);
//     to_nat_left(zs);
//     to_nat_left(zs') + z * pow;
//     { lemma_seq_add(xs.drop_last(), DropLast(ys), zs', cin); }
//     to_nat_left(xs.drop_last()) + to_nat_left(DropLast(ys)) - cin * pow + z * pow;
//     {
//         lemma_mul_equality(sum, z + cout * base, pow);
//         assert sum * pow == (z + cout * base) * pow;
//         lemma_mul_is_distributive_auto();
//     }
//     to_nat_left(xs, base) + to_nat_left(ys, base) - cout * base * pow;
//     {
//         lemma_mul_is_associative(cout, base, pow);
//         reveal pow();
//     }
//     to_nat_left(xs, base) + to_nat_left(ys, base) - cout * pow(base, |xs|);
//     to_nat_right(xs, base) + to_nat_right(ys, base) - cout * pow(base, |xs|);
//     }
// }
// }

// /* Subtracts two sequences. */
// function {:opaque} SeqSub(xs: Seq<int>, ys: Seq<int>): (Seq<int>, nat)
// requires |xs| == |ys|
// ensures var (zs, cout) := SeqSub(xs, ys);
//         |zs| == |xs| && 0 <= cout <= 1
// decreases xs
// {
// if |xs| == 0 then ([], 0)
// else
//     var (zs, cin) := SeqSub(xs.drop_last(), DropLast(ys));
//     var (diff_out, cout) := if xs.last() >= Last(ys) + cin
//                             then (xs.last() - Last(ys) - cin, 0)
//                             else (base + xs.last() - Last(ys) - cin, 1);
//     (zs + [diff_out], cout)
// }

// /* SeqSub returns the same value as converting the sequences to nats, then
// subtracting them. */
// proof fn vcs_split_on_every_assert} lemma_seq_sub(xs: Seq<int>, ys: Seq<int>, zs: Seq<int>, cout: nat)
// requires |xs| == |ys|
// requires SeqSub(xs, ys) == (zs, cout)
// ensures to_nat_right(xs, base) - to_nat_right(ys, base) + cout * pow(base, |xs|) == to_nat_right(zs)
// {
// reveal SeqSub();
// if |xs| == 0 {
//     reveal to_nat_right();
// } else {
//     var pow := pow(base, (xs.len() - 1) as nat);
//     var (zs', cin) := SeqSub(xs.drop_last(), DropLast(ys));
//     var z := if xs.last() >= Last(ys) + cin
//     then xs.last() - Last(ys) - cin
//     else base + xs.last() - Last(ys) - cin;
//     assert cout * base + xs.last() - cin - Last(ys) == z;

//     reveal to_nat_left();
//     lemma_to_nat_left_eqto_nat_right_auto();
//     calc {
//     to_nat_right(zs);
//     to_nat_left(zs);
//     to_nat_left(zs') + z * pow;
//     { lemma_seq_sub(xs.drop_last(), DropLast(ys), zs', cin); }
//     to_nat_left(xs.drop_last()) - to_nat_left(DropLast(ys)) + cin * pow + z * pow;
//     {
//         lemma_mul_equality(cout * base + xs.last() - cin - Last(ys), z, pow);
//         assert pow * (cout * base + xs.last() - cin - Last(ys)) == pow * z;
//         lemma_mul_is_distributive_auto();
//     }
//     to_nat_left(xs, base) - to_nat_left(ys, base) + cout * base * pow;
//     {
//         lemma_mul_is_associative(cout, base, pow);
//         reveal pow();
//     }
//     to_nat_left(xs, base) - to_nat_left(ys, base) + cout * pow(base, |xs|);
//     to_nat_right(xs, base) - to_nat_right(ys, base) + cout * pow(base, |xs|);
//     }
// }
// }
}